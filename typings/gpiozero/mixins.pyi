"""
This type stub file was generated by pyright.
"""

from .threads import GPIOThread

nstr = str
str = ...
callback_warning = ...
class ValuesMixin:
    """
    Adds a :attr:`values` property to the class which returns an infinite
    generator of readings from the :attr:`~Device.value` property. There is
    rarely a need to use this mixin directly as all base classes in GPIO Zero
    include it.

    .. note::

        Use this mixin *first* in the parent class list.
    """
    @property
    def values(self): # -> Generator[Unknown, None, None]:
        """
        An infinite iterator of values read from :attr:`value`.
        """
        ...
    


class SourceMixin:
    """
    Adds a :attr:`source` property to the class which, given an iterable or a
    :class:`ValuesMixin` descendent, sets :attr:`~Device.value` to each member
    of that iterable until it is exhausted. This mixin is generally included in
    novel output devices to allow their state to be driven from another device.

    .. note::

        Use this mixin *first* in the parent class list.
    """
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def close(self): # -> None:
        ...
    
    @property
    def source_delay(self): # -> float:
        """
        The delay (measured in seconds) in the loop used to read values from
        :attr:`source`. Defaults to 0.01 seconds which is generally sufficient
        to keep CPU usage to a minimum while providing adequate responsiveness.
        """
        ...
    
    @source_delay.setter
    def source_delay(self, value): # -> None:
        ...
    
    @property
    def source(self): # -> Generator[Unknown, None, None] | None:
        """
        The iterable to use as a source of values for :attr:`value`.
        """
        ...
    
    @source.setter
    def source(self, value): # -> None:
        ...
    


class SharedMixin:
    """
    This mixin marks a class as "shared". In this case, the meta-class
    (GPIOMeta) will use :meth:`_shared_key` to convert the constructor
    arguments to an immutable key, and will check whether any existing
    instances match that key. If they do, they will be returned by the
    constructor instead of a new instance. An internal reference counter is
    used to determine how many times an instance has been "constructed" in this
    way.

    When :meth:`~Device.close` is called, an internal reference counter will be
    decremented and the instance will only close when it reaches zero.
    """
    _instances = ...
    def __del__(self): # -> None:
        ...
    


class EventsMixin:
    """
    Adds edge-detected :meth:`when_activated` and :meth:`when_deactivated`
    events to a device based on changes to the :attr:`~Device.is_active`
    property common to all devices. Also adds :meth:`wait_for_active` and
    :meth:`wait_for_inactive` methods for level-waiting.

    .. note::

        Note that this mixin provides no means of actually firing its events;
        call :meth:`_fire_events` in sub-classes when device state changes to
        trigger the events. This should also be called once at the end of
        initialization to set initial states.
    """
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def wait_for_active(self, timeout=...): # -> bool:
        """
        Pause the script until the device is activated, or the timeout is
        reached.

        :type timeout: float or None
        :param timeout:
            Number of seconds to wait before proceeding. If this is
            :data:`None` (the default), then wait indefinitely until the device
            is active.
        """
        ...
    
    def wait_for_inactive(self, timeout=...): # -> bool:
        """
        Pause the script until the device is deactivated, or the timeout is
        reached.

        :type timeout: float or None
        :param timeout:
            Number of seconds to wait before proceeding. If this is
            :data:`None` (the default), then wait indefinitely until the device
            is inactive.
        """
        ...
    
    @property
    def when_activated(self): # -> None:
        """
        The function to run when the device changes state from inactive to
        active.

        This can be set to a function which accepts no (mandatory) parameters,
        or a Python function which accepts a single mandatory parameter (with
        as many optional parameters as you like). If the function accepts a
        single mandatory parameter, the device that activated will be passed
        as that parameter.

        Set this property to :data:`None` (the default) to disable the event.
        """
        ...
    
    @when_activated.setter
    def when_activated(self, value): # -> None:
        ...
    
    @property
    def when_deactivated(self): # -> None:
        """
        The function to run when the device changes state from active to
        inactive.

        This can be set to a function which accepts no (mandatory) parameters,
        or a Python function which accepts a single mandatory parameter (with
        as many optional parameters as you like). If the function accepts a
        single mandatory parameter, the device that deactivated will be
        passed as that parameter.

        Set this property to :data:`None` (the default) to disable the event.
        """
        ...
    
    @when_deactivated.setter
    def when_deactivated(self, value): # -> None:
        ...
    
    @property
    def active_time(self): # -> None:
        """
        The length of time (in seconds) that the device has been active for.
        When the device is inactive, this is :data:`None`.
        """
        ...
    
    @property
    def inactive_time(self): # -> None:
        """
        The length of time (in seconds) that the device has been inactive for.
        When the device is active, this is :data:`None`.
        """
        ...
    


class HoldMixin(EventsMixin):
    """
    Extends :class:`EventsMixin` to add the :attr:`when_held` event and the
    machinery to fire that event repeatedly (when :attr:`hold_repeat` is
    :data:`True`) at internals defined by :attr:`hold_time`.
    """
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def close(self): # -> None:
        ...
    
    @property
    def when_held(self): # -> None:
        """
        The function to run when the device has remained active for
        :attr:`hold_time` seconds.

        This can be set to a function which accepts no (mandatory) parameters,
        or a Python function which accepts a single mandatory parameter (with
        as many optional parameters as you like). If the function accepts a
        single mandatory parameter, the device that activated will be passed
        as that parameter.

        Set this property to :data:`None` (the default) to disable the event.
        """
        ...
    
    @when_held.setter
    def when_held(self, value): # -> None:
        ...
    
    @property
    def hold_time(self): # -> int | float:
        """
        The length of time (in seconds) to wait after the device is activated,
        until executing the :attr:`when_held` handler. If :attr:`hold_repeat`
        is True, this is also the length of time between invocations of
        :attr:`when_held`.
        """
        ...
    
    @hold_time.setter
    def hold_time(self, value): # -> None:
        ...
    
    @property
    def hold_repeat(self): # -> bool:
        """
        If :data:`True`, :attr:`when_held` will be executed repeatedly with
        :attr:`hold_time` seconds between each invocation.
        """
        ...
    
    @hold_repeat.setter
    def hold_repeat(self, value): # -> None:
        ...
    
    @property
    def is_held(self): # -> bool:
        """
        When :data:`True`, the device has been active for at least
        :attr:`hold_time` seconds.
        """
        ...
    
    @property
    def held_time(self): # -> None:
        """
        The length of time (in seconds) that the device has been held for.
        This is counted from the first execution of the :attr:`when_held` event
        rather than when the device activated, in contrast to
        :attr:`~EventsMixin.active_time`. If the device is not currently held,
        this is :data:`None`.
        """
        ...
    


class HoldThread(GPIOThread):
    """
    Extends :class:`GPIOThread`. Provides a background thread that repeatedly
    fires the :attr:`HoldMixin.when_held` event as long as the owning
    device is active.
    """
    def __init__(self, parent) -> None:
        ...
    
    def held(self, parent):
        ...
    


class GPIOQueue(GPIOThread):
    """
    Extends :class:`GPIOThread`. Provides a background thread that monitors a
    device's values and provides a running *average* (defaults to median) of
    those values. If the *parent* device includes the :class:`EventsMixin` in
    its ancestry, the thread automatically calls
    :meth:`~EventsMixin._fire_events`.
    """
    def __init__(self, parent, queue_len=..., sample_wait=..., partial=..., average=..., ignore=...) -> None:
        ...
    
    @property
    def value(self): # -> float:
        ...
    
    def fill(self): # -> None:
        ...
    


