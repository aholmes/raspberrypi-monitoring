"""
This type stub file was generated by pyright.
"""

from .devices import CompositeDevice, Device, GPIODevice
from .mixins import SourceMixin

str = ...
class OutputDevice(SourceMixin, GPIODevice):
    """
    Represents a generic GPIO output device.

    This class extends :class:`GPIODevice` to add facilities common to GPIO
    output devices: an :meth:`on` method to switch the device on, a
    corresponding :meth:`off` method, and a :meth:`toggle` method.

    :type pin: int or str
    :param pin:
        The GPIO pin that the device is connected to. See :ref:`pin-numbering`
        for valid pin numbers. If this is :data:`None` a :exc:`GPIODeviceError`
        will be raised.

    :param bool active_high:
        If :data:`True` (the default), the :meth:`on` method will set the GPIO
        to HIGH. If :data:`False`, the :meth:`on` method will set the GPIO to
        LOW (the :meth:`off` method always does the opposite).

    :type initial_value: bool or None
    :param initial_value:
        If :data:`False` (the default), the device will be off initially.  If
        :data:`None`, the device will be left in whatever state the pin is
        found in when configured for output (warning: this can be on).  If
        :data:`True`, the device will be switched on initially.

    :type pin_factory: Factory or None
    :param pin_factory:
        See :doc:`api_pins` for more information (this is an advanced feature
        which most users can ignore).
    """
    def __init__(self, pin=..., active_high=..., initial_value=..., pin_factory=...) -> None:
        ...
    
    def on(self): # -> None:
        """
        Turns the device on.
        """
        ...
    
    def off(self): # -> None:
        """
        Turns the device off.
        """
        ...
    
    def toggle(self): # -> None:
        """
        Reverse the state of the device. If it's on, turn it off; if it's off,
        turn it on.
        """
        ...
    
    @property
    def value(self):
        """
        Returns 1 if the device is currently active and 0 otherwise. Setting
        this property changes the state of the device.
        """
        ...
    
    @value.setter
    def value(self, value): # -> None:
        ...
    
    @property
    def active_high(self): # -> bool:
        """
        When :data:`True`, the :attr:`value` property is :data:`True` when the
        device's :attr:`~GPIODevice.pin` is high. When :data:`False` the
        :attr:`value` property is :data:`True` when the device's pin is low
        (i.e. the value is inverted).

        This property can be set after construction; be warned that changing it
        will invert :attr:`value` (i.e. changing this property doesn't change
        the device's pin state - it just changes how that state is
        interpreted).
        """
        ...
    
    @active_high.setter
    def active_high(self, value): # -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    


class DigitalOutputDevice(OutputDevice):
    """
    Represents a generic output device with typical on/off behaviour.

    This class extends :class:`OutputDevice` with a :meth:`blink` method which
    uses an optional background thread to handle toggling the device state
    without further interaction.

    :type pin: int or str
    :param pin:
        The GPIO pin that the device is connected to. See :ref:`pin-numbering`
        for valid pin numbers. If this is :data:`None` a :exc:`GPIODeviceError`
        will be raised.

    :param bool active_high:
        If :data:`True` (the default), the :meth:`on` method will set the GPIO
        to HIGH. If :data:`False`, the :meth:`on` method will set the GPIO to
        LOW (the :meth:`off` method always does the opposite).

    :type initial_value: bool or None
    :param initial_value:
        If :data:`False` (the default), the device will be off initially.  If
        :data:`None`, the device will be left in whatever state the pin is
        found in when configured for output (warning: this can be on).  If
        :data:`True`, the device will be switched on initially.

    :type pin_factory: Factory or None
    :param pin_factory:
        See :doc:`api_pins` for more information (this is an advanced feature
        which most users can ignore).
    """
    def __init__(self, pin=..., active_high=..., initial_value=..., pin_factory=...) -> None:
        ...
    
    @property
    def value(self):
        ...
    
    @value.setter
    def value(self, value): # -> None:
        ...
    
    def close(self): # -> None:
        ...
    
    def on(self): # -> None:
        ...
    
    def off(self): # -> None:
        ...
    
    def blink(self, on_time=..., off_time=..., n=..., background=...): # -> None:
        """
        Make the device turn on and off repeatedly.

        :param float on_time:
            Number of seconds on. Defaults to 1 second.

        :param float off_time:
            Number of seconds off. Defaults to 1 second.

        :type n: int or None
        :param n:
            Number of times to blink; :data:`None` (the default) means forever.

        :param bool background:
            If :data:`True` (the default), start a background thread to
            continue blinking and return immediately. If :data:`False`, only
            return when the blink is finished (warning: the default value of
            *n* will result in this method never returning).
        """
        ...
    


class LED(DigitalOutputDevice):
    """
    Extends :class:`DigitalOutputDevice` and represents a light emitting diode
    (LED).

    Connect the cathode (short leg, flat side) of the LED to a ground pin;
    connect the anode (longer leg) to a limiting resistor; connect the other
    side of the limiting resistor to a GPIO pin (the limiting resistor can be
    placed either side of the LED).

    The following example will light the LED::

        from gpiozero import LED

        led = LED(17)
        led.on()

    :type pin: int or str
    :param pin:
        The GPIO pin which the LED is connected to. See :ref:`pin-numbering`
        for valid pin numbers. If this is :data:`None` a :exc:`GPIODeviceError`
        will be raised.

    :param bool active_high:
        If :data:`True` (the default), the LED will operate normally with the
        circuit described above. If :data:`False` you should wire the cathode
        to the GPIO pin, and the anode to a 3V3 pin (via a limiting resistor).

    :type initial_value: bool or None
    :param initial_value:
        If :data:`False` (the default), the LED will be off initially.  If
        :data:`None`, the LED will be left in whatever state the pin is found
        in when configured for output (warning: this can be on).  If
        :data:`True`, the LED will be switched on initially.

    :type pin_factory: Factory or None
    :param pin_factory:
        See :doc:`api_pins` for more information (this is an advanced feature
        which most users can ignore).
    """
    ...


class Buzzer(DigitalOutputDevice):
    """
    Extends :class:`DigitalOutputDevice` and represents a digital buzzer
    component.

    .. note::

        This interface is only capable of simple on/off commands, and is not
        capable of playing a variety of tones (see :class:`TonalBuzzer`).

    Connect the cathode (negative pin) of the buzzer to a ground pin; connect
    the other side to any GPIO pin.

    The following example will sound the buzzer::

        from gpiozero import Buzzer

        bz = Buzzer(3)
        bz.on()

    :type pin: int or str
    :param pin:
        The GPIO pin which the buzzer is connected to. See :ref:`pin-numbering`
        for valid pin numbers. If this is :data:`None` a :exc:`GPIODeviceError`
        will be raised.

    :param bool active_high:
        If :data:`True` (the default), the buzzer will operate normally with
        the circuit described above. If :data:`False` you should wire the
        cathode to the GPIO pin, and the anode to a 3V3 pin.

    :type initial_value: bool or None
    :param initial_value:
        If :data:`False` (the default), the buzzer will be silent initially. If
        :data:`None`, the buzzer will be left in whatever state the pin is
        found in when configured for output (warning: this can be on). If
        :data:`True`, the buzzer will be switched on initially.

    :type pin_factory: Factory or None
    :param pin_factory:
        See :doc:`api_pins` for more information (this is an advanced feature
        which most users can ignore).
    """
    ...


class PWMOutputDevice(OutputDevice):
    """
    Generic output device configured for pulse-width modulation (PWM).

    :type pin: int or str
    :param pin:
        The GPIO pin that the device is connected to. See :ref:`pin-numbering`
        for valid pin numbers. If this is :data:`None` a :exc:`GPIODeviceError`
        will be raised.

    :param bool active_high:
        If :data:`True` (the default), the :meth:`on` method will set the GPIO
        to HIGH. If :data:`False`, the :meth:`on` method will set the GPIO to
        LOW (the :meth:`off` method always does the opposite).

    :param float initial_value:
        If 0 (the default), the device's duty cycle will be 0 initially.
        Other values between 0 and 1 can be specified as an initial duty cycle.
        Note that :data:`None` cannot be specified (unlike the parent class) as
        there is no way to tell PWM not to alter the state of the pin.

    :param int frequency:
        The frequency (in Hz) of pulses emitted to drive the device. Defaults
        to 100Hz.

    :type pin_factory: Factory or None
    :param pin_factory:
        See :doc:`api_pins` for more information (this is an advanced feature
        which most users can ignore).
    """
    def __init__(self, pin=..., active_high=..., initial_value=..., frequency=..., pin_factory=...) -> None:
        ...
    
    def close(self): # -> None:
        ...
    
    @property
    def value(self):
        """
        The duty cycle of the PWM device. 0.0 is off, 1.0 is fully on. Values
        in between may be specified for varying levels of power in the device.
        """
        ...
    
    @value.setter
    def value(self, value): # -> None:
        ...
    
    def on(self): # -> None:
        ...
    
    def off(self): # -> None:
        ...
    
    def toggle(self): # -> None:
        """
        Toggle the state of the device. If the device is currently off
        (:attr:`value` is 0.0), this changes it to "fully" on (:attr:`value` is
        1.0).  If the device has a duty cycle (:attr:`value`) of 0.1, this will
        toggle it to 0.9, and so on.
        """
        ...
    
    @property
    def is_active(self):
        """
        Returns :data:`True` if the device is currently active (:attr:`value`
        is non-zero) and :data:`False` otherwise.
        """
        ...
    
    @property
    def frequency(self): # -> Any:
        """
        The frequency of the pulses used with the PWM device, in Hz. The
        default is 100Hz.
        """
        ...
    
    @frequency.setter
    def frequency(self, value): # -> None:
        ...
    
    def blink(self, on_time=..., off_time=..., fade_in_time=..., fade_out_time=..., n=..., background=...): # -> None:
        """
        Make the device turn on and off repeatedly.

        :param float on_time:
            Number of seconds on. Defaults to 1 second.

        :param float off_time:
            Number of seconds off. Defaults to 1 second.

        :param float fade_in_time:
            Number of seconds to spend fading in. Defaults to 0.

        :param float fade_out_time:
            Number of seconds to spend fading out. Defaults to 0.

        :type n: int or None
        :param n:
            Number of times to blink; :data:`None` (the default) means forever.

        :param bool background:
            If :data:`True` (the default), start a background thread to
            continue blinking and return immediately. If :data:`False`, only
            return when the blink is finished (warning: the default value of
            *n* will result in this method never returning).
        """
        ...
    
    def pulse(self, fade_in_time=..., fade_out_time=..., n=..., background=...): # -> None:
        """
        Make the device fade in and out repeatedly.

        :param float fade_in_time:
            Number of seconds to spend fading in. Defaults to 1.

        :param float fade_out_time:
            Number of seconds to spend fading out. Defaults to 1.

        :type n: int or None
        :param n:
            Number of times to pulse; :data:`None` (the default) means forever.

        :param bool background:
            If :data:`True` (the default), start a background thread to
            continue pulsing and return immediately. If :data:`False`, only
            return when the pulse is finished (warning: the default value of
            *n* will result in this method never returning).
        """
        ...
    


class TonalBuzzer(SourceMixin, CompositeDevice):
    """
    Extends :class:`CompositeDevice` and represents a tonal buzzer.

    :type pin: int or str
    :param pin:
        The GPIO pin which the buzzer is connected to. See :ref:`pin-numbering`
        for valid pin numbers. If this is :data:`None` a :exc:`GPIODeviceError`
        will be raised.

    :param float initial_value:
        If :data:`None` (the default), the buzzer will be off initially. Values
        between -1 and 1 can be specified as an initial value for the buzzer.

    :type mid_tone: int or str
    :param mid_tone:
        The tone which is represented the device's middle value (0). The
        default is "A4" (MIDI note 69).

    :param int octaves:
        The number of octaves to allow away from the base note. The default is
        1, meaning a value of -1 goes one octave below the base note, and one
        above, i.e. from A3 to A5 with the default base note of A4.

    :type pin_factory: Factory or None
    :param pin_factory:
        See :doc:`api_pins` for more information (this is an advanced feature
        which most users can ignore).

    .. note::

        Note that this class does not currently work with
        :class:`~gpiozero.pins.pigpio.PiGPIOFactory`.
    """
    def __init__(self, pin=..., initial_value=..., mid_tone=..., octaves=..., pin_factory=...) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def play(self, tone): # -> None:
        """
        Play the given *tone*. This can either be an instance of
        :class:`~gpiozero.tones.Tone` or can be anything that could be used to
        construct an instance of :class:`~gpiozero.tones.Tone`.

        For example::

            >>> from gpiozero import TonalBuzzer
            >>> from gpiozero.tones import Tone
            >>> b = TonalBuzzer(17)
            >>> b.play(Tone("A4"))
            >>> b.play(Tone(220.0)) # Hz
            >>> b.play(Tone(60)) # middle C in MIDI notation
            >>> b.play("A4")
            >>> b.play(220.0)
            >>> b.play(60)
        """
        ...
    
    def stop(self): # -> None:
        """
        Turn the buzzer off. This is equivalent to setting :attr:`value` to
        :data:`None`.
        """
        ...
    
    @property
    def tone(self): # -> Tone | None:
        """
        Returns the :class:`~gpiozero.tones.Tone` that the buzzer is currently
        playing, or :data:`None` if the buzzer is silent. This property can
        also be set to play the specified tone.
        """
        ...
    
    @tone.setter
    def tone(self, value): # -> None:
        ...
    
    @property
    def value(self): # -> float | None:
        """
        Represents the state of the buzzer as a value between -1 (representing
        the minimum tone) and 1 (representing the maximum tone). This can also
        be the special value :data:`None` indicating that the buzzer is
        currently silent.
        """
        ...
    
    @value.setter
    def value(self, value): # -> None:
        ...
    
    @property
    def is_active(self): # -> bool:
        """
        Returns :data:`True` if the buzzer is currently playing, otherwise
        :data:`False`.
        """
        ...
    
    @property
    def octaves(self): # -> Unknown:
        """
        The number of octaves available (above and below mid_tone).
        """
        ...
    
    @property
    def min_tone(self): # -> Tone:
        """
        The lowest tone that the buzzer can play, i.e. the tone played
        when :attr:`value` is -1.
        """
        ...
    
    @property
    def mid_tone(self): # -> Tone | None:
        """
        The middle tone available, i.e. the tone played when :attr:`value` is
        0.
        """
        ...
    
    @property
    def max_tone(self): # -> Tone:
        """
        The highest tone that the buzzer can play, i.e. the tone played when
        :attr:`value` is 1.
        """
        ...
    


class PWMLED(PWMOutputDevice):
    """
    Extends :class:`PWMOutputDevice` and represents a light emitting diode
    (LED) with variable brightness.

    A typical configuration of such a device is to connect a GPIO pin to the
    anode (long leg) of the LED, and the cathode (short leg) to ground, with
    an optional resistor to prevent the LED from burning out.

    :type pin: int or str
    :param pin:
        The GPIO pin which the LED is connected to. See :ref:`pin-numbering`
        for valid pin numbers. If this is :data:`None` a :exc:`GPIODeviceError`
        will be raised.

    :param bool active_high:
        If :data:`True` (the default), the :meth:`on` method will set the GPIO
        to HIGH. If :data:`False`, the :meth:`on` method will set the GPIO to
        LOW (the :meth:`off` method always does the opposite).

    :param float initial_value:
        If ``0`` (the default), the LED will be off initially. Other values
        between 0 and 1 can be specified as an initial brightness for the LED.
        Note that :data:`None` cannot be specified (unlike the parent class) as
        there is no way to tell PWM not to alter the state of the pin.

    :param int frequency:
        The frequency (in Hz) of pulses emitted to drive the LED. Defaults
        to 100Hz.

    :type pin_factory: Factory or None
    :param pin_factory:
        See :doc:`api_pins` for more information (this is an advanced feature
        which most users can ignore).
    """
    ...


class RGBLED(SourceMixin, Device):
    """
    Extends :class:`Device` and represents a full color LED component (composed
    of red, green, and blue LEDs).

    Connect the common cathode (longest leg) to a ground pin; connect each of
    the other legs (representing the red, green, and blue anodes) to any GPIO
    pins.  You should use three limiting resistors (one per anode).

    The following code will make the LED yellow::

        from gpiozero import RGBLED

        led = RGBLED(2, 3, 4)
        led.color = (1, 1, 0)

    The `colorzero`_ library is also supported::

        from gpiozero import RGBLED
        from colorzero import Color

        led = RGBLED(2, 3, 4)
        led.color = Color('yellow')

    :type red: int or str
    :param red:
        The GPIO pin that controls the red component of the RGB LED. See
        :ref:`pin-numbering` for valid pin numbers. If this is :data:`None` a
        :exc:`GPIODeviceError` will be raised.

    :type green: int or str
    :param green:
        The GPIO pin that controls the green component of the RGB LED.

    :type blue: int or str
    :param blue:
        The GPIO pin that controls the blue component of the RGB LED.

    :param bool active_high:
        Set to :data:`True` (the default) for common cathode RGB LEDs. If you
        are using a common anode RGB LED, set this to :data:`False`.

    :type initial_value: ~colorzero.Color or tuple
    :param initial_value:
        The initial color for the RGB LED. Defaults to black ``(0, 0, 0)``.

    :param bool pwm:
        If :data:`True` (the default), construct :class:`PWMLED` instances for
        each component of the RGBLED. If :data:`False`, construct regular
        :class:`LED` instances, which prevents smooth color graduations.

    :type pin_factory: Factory or None
    :param pin_factory:
        See :doc:`api_pins` for more information (this is an advanced feature
        which most users can ignore).

    .. _colorzero: https://colorzero.readthedocs.io/
    """
    def __init__(self, red=..., green=..., blue=..., active_high=..., initial_value=..., pwm=..., pin_factory=...) -> None:
        ...
    
    def close(self): # -> None:
        ...
    
    @property
    def closed(self): # -> bool:
        ...
    
    @property
    def value(self): # -> tuple[Unknown, ...]:
        """
        Represents the color of the LED as an RGB 3-tuple of ``(red, green,
        blue)`` where each value is between 0 and 1 if *pwm* was :data:`True`
        when the class was constructed (and only 0 or 1 if not).

        For example, red would be ``(1, 0, 0)`` and yellow would be ``(1, 1,
        0)``, while orange would be ``(1, 0.5, 0)``.
        """
        ...
    
    @value.setter
    def value(self, value): # -> None:
        ...
    
    @property
    def is_active(self): # -> bool:
        """
        Returns :data:`True` if the LED is currently active (not black) and
        :data:`False` otherwise.
        """
        ...
    
    is_lit = ...
    @property
    def color(self): # -> Color:
        """
        Represents the color of the LED as a :class:`~colorzero.Color` object.
        """
        ...
    
    @color.setter
    def color(self, value): # -> None:
        ...
    
    @property
    def red(self): # -> Red:
        """
        Represents the red element of the LED as a :class:`~colorzero.Red`
        object.
        """
        ...
    
    @red.setter
    def red(self, value): # -> None:
        ...
    
    @property
    def green(self): # -> Green:
        """
        Represents the green element of the LED as a :class:`~colorzero.Green`
        object.
        """
        ...
    
    @green.setter
    def green(self, value): # -> None:
        ...
    
    @property
    def blue(self): # -> Blue:
        """
        Represents the blue element of the LED as a :class:`~colorzero.Blue`
        object.
        """
        ...
    
    @blue.setter
    def blue(self, value): # -> None:
        ...
    
    def on(self): # -> None:
        """
        Turn the LED on. This equivalent to setting the LED color to white
        ``(1, 1, 1)``.
        """
        ...
    
    def off(self): # -> None:
        """
        Turn the LED off. This is equivalent to setting the LED color to black
        ``(0, 0, 0)``.
        """
        ...
    
    def toggle(self): # -> None:
        """
        Toggle the state of the device. If the device is currently off
        (:attr:`value` is ``(0, 0, 0)``), this changes it to "fully" on
        (:attr:`value` is ``(1, 1, 1)``).  If the device has a specific color,
        this method inverts the color.
        """
        ...
    
    def blink(self, on_time=..., off_time=..., fade_in_time=..., fade_out_time=..., on_color=..., off_color=..., n=..., background=...): # -> None:
        """
        Make the device turn on and off repeatedly.

        :param float on_time:
            Number of seconds on. Defaults to 1 second.

        :param float off_time:
            Number of seconds off. Defaults to 1 second.

        :param float fade_in_time:
            Number of seconds to spend fading in. Defaults to 0. Must be 0 if
            *pwm* was :data:`False` when the class was constructed
            (:exc:`ValueError` will be raised if not).

        :param float fade_out_time:
            Number of seconds to spend fading out. Defaults to 0. Must be 0 if
            *pwm* was :data:`False` when the class was constructed
            (:exc:`ValueError` will be raised if not).

        :type on_color: ~colorzero.Color or tuple
        :param on_color:
            The color to use when the LED is "on". Defaults to white.

        :type off_color: ~colorzero.Color or tuple
        :param off_color:
            The color to use when the LED is "off". Defaults to black.

        :type n: int or None
        :param n:
            Number of times to blink; :data:`None` (the default) means forever.

        :param bool background:
            If :data:`True` (the default), start a background thread to
            continue blinking and return immediately. If :data:`False`, only
            return when the blink is finished (warning: the default value of
            *n* will result in this method never returning).
        """
        ...
    
    def pulse(self, fade_in_time=..., fade_out_time=..., on_color=..., off_color=..., n=..., background=...): # -> None:
        """
        Make the device fade in and out repeatedly.

        :param float fade_in_time:
            Number of seconds to spend fading in. Defaults to 1.

        :param float fade_out_time:
            Number of seconds to spend fading out. Defaults to 1.

        :type on_color: ~colorzero.Color or tuple
        :param on_color:
            The color to use when the LED is "on". Defaults to white.

        :type off_color: ~colorzero.Color or tuple
        :param off_color:
            The color to use when the LED is "off". Defaults to black.

        :type n: int or None
        :param n:
            Number of times to pulse; :data:`None` (the default) means forever.

        :param bool background:
            If :data:`True` (the default), start a background thread to
            continue pulsing and return immediately. If :data:`False`, only
            return when the pulse is finished (warning: the default value of
            *n* will result in this method never returning).
        """
        ...
    


class Motor(SourceMixin, CompositeDevice):
    """
    Extends :class:`CompositeDevice` and represents a generic motor
    connected to a bi-directional motor driver circuit (i.e. an `H-bridge`_).

    Attach an `H-bridge`_ motor controller to your Pi; connect a power source
    (e.g. a battery pack or the 5V pin) to the controller; connect the outputs
    of the controller board to the two terminals of the motor; connect the
    inputs of the controller board to two GPIO pins.

    .. _H-bridge: https://en.wikipedia.org/wiki/H_bridge

    The following code will make the motor turn "forwards"::

        from gpiozero import Motor

        motor = Motor(17, 18)
        motor.forward()

    :type forward: int or str
    :param forward:
        The GPIO pin that the forward input of the motor driver chip is
        connected to. See :ref:`pin-numbering` for valid pin numbers. If this
        is :data:`None` a :exc:`GPIODeviceError` will be raised.

    :type backward: int or str
    :param backward:
        The GPIO pin that the backward input of the motor driver chip is
        connected to. See :ref:`pin-numbering` for valid pin numbers. If this
        is :data:`None` a :exc:`GPIODeviceError` will be raised.

    :type enable: int or str or None
    :param enable:
        The GPIO pin that enables the motor. Required for *some* motor
        controller boards. See :ref:`pin-numbering` for valid pin numbers.

    :param bool pwm:
        If :data:`True` (the default), construct :class:`PWMOutputDevice`
        instances for the motor controller pins, allowing both direction and
        variable speed control. If :data:`False`, construct
        :class:`DigitalOutputDevice` instances, allowing only direction
        control.

    :type pin_factory: Factory or None
    :param pin_factory:
        See :doc:`api_pins` for more information (this is an advanced feature
        which most users can ignore).
    """
    def __init__(self, forward=..., backward=..., enable=..., pwm=..., pin_factory=...) -> None:
        ...
    
    @property
    def value(self):
        """
        Represents the speed of the motor as a floating point value between -1
        (full speed backward) and 1 (full speed forward), with 0 representing
        stopped.
        """
        ...
    
    @value.setter
    def value(self, value):
        ...
    
    @property
    def is_active(self):
        """
        Returns :data:`True` if the motor is currently running and
        :data:`False` otherwise.
        """
        ...
    
    def forward(self, speed=...): # -> None:
        """
        Drive the motor forwards.

        :param float speed:
            The speed at which the motor should turn. Can be any value between
            0 (stopped) and the default 1 (maximum speed) if *pwm* was
            :data:`True` when the class was constructed (and only 0 or 1 if
            not).
        """
        ...
    
    def backward(self, speed=...): # -> None:
        """
        Drive the motor backwards.

        :param float speed:
            The speed at which the motor should turn. Can be any value between
            0 (stopped) and the default 1 (maximum speed) if *pwm* was
            :data:`True` when the class was constructed (and only 0 or 1 if
            not).
        """
        ...
    
    def reverse(self): # -> None:
        """
        Reverse the current direction of the motor. If the motor is currently
        idle this does nothing. Otherwise, the motor's direction will be
        reversed at the current speed.
        """
        ...
    
    def stop(self): # -> None:
        """
        Stop the motor.
        """
        ...
    


class PhaseEnableMotor(SourceMixin, CompositeDevice):
    """
    Extends :class:`CompositeDevice` and represents a generic motor connected
    to a Phase/Enable motor driver circuit; the phase of the driver controls
    whether the motor turns forwards or backwards, while enable controls the
    speed with PWM.

    The following code will make the motor turn "forwards"::

        from gpiozero import PhaseEnableMotor
        motor = PhaseEnableMotor(12, 5)
        motor.forward()

    :type phase: int or str
    :param phase:
        The GPIO pin that the phase (direction) input of the motor driver chip
        is connected to. See :ref:`pin-numbering` for valid pin numbers. If
        this is :data:`None` a :exc:`GPIODeviceError` will be raised.

    :type enable: int or str
    :param enable:
        The GPIO pin that the enable (speed) input of the motor driver chip
        is connected to. See :ref:`pin-numbering` for valid pin numbers. If
        this is :data:`None` a :exc:`GPIODeviceError` will be raised.

    :param bool pwm:
        If :data:`True` (the default), construct :class:`PWMOutputDevice`
        instances for the motor controller pins, allowing both direction and
        variable speed control. If :data:`False`, construct
        :class:`DigitalOutputDevice` instances, allowing only direction
        control.

    :type pin_factory: Factory or None
    :param pin_factory:
        See :doc:`api_pins` for more information (this is an advanced feature
        which most users can ignore).
    """
    def __init__(self, phase=..., enable=..., pwm=..., pin_factory=...) -> None:
        ...
    
    @property
    def value(self):
        """
        Represents the speed of the motor as a floating point value between -1
        (full speed backward) and 1 (full speed forward).
        """
        ...
    
    @value.setter
    def value(self, value): # -> None:
        ...
    
    @property
    def is_active(self):
        """
        Returns :data:`True` if the motor is currently running and
        :data:`False` otherwise.
        """
        ...
    
    def forward(self, speed=...): # -> None:
        """
        Drive the motor forwards.

        :param float speed:
            The speed at which the motor should turn. Can be any value between
            0 (stopped) and the default 1 (maximum speed).
        """
        ...
    
    def backward(self, speed=...): # -> None:
        """
        Drive the motor backwards.

        :param float speed:
            The speed at which the motor should turn. Can be any value between
            0 (stopped) and the default 1 (maximum speed).
        """
        ...
    
    def reverse(self): # -> None:
        """
        Reverse the current direction of the motor. If the motor is currently
        idle this does nothing. Otherwise, the motor's direction will be
        reversed at the current speed.
        """
        ...
    
    def stop(self): # -> None:
        """
        Stop the motor.
        """
        ...
    


class Servo(SourceMixin, CompositeDevice):
    """
    Extends :class:`CompositeDevice` and represents a PWM-controlled servo
    motor connected to a GPIO pin.

    Connect a power source (e.g. a battery pack or the 5V pin) to the power
    cable of the servo (this is typically colored red); connect the ground
    cable of the servo (typically colored black or brown) to the negative of
    your battery pack, or a GND pin; connect the final cable (typically colored
    white or orange) to the GPIO pin you wish to use for controlling the servo.

    The following code will make the servo move between its minimum, maximum,
    and mid-point positions with a pause between each::

        from gpiozero import Servo
        from time import sleep

        servo = Servo(17)

        while True:
            servo.min()
            sleep(1)
            servo.mid()
            sleep(1)
            servo.max()
            sleep(1)

    You can also use the :attr:`value` property to move the servo to a
    particular position, on a scale from -1 (min) to 1 (max) where 0 is the
    mid-point::

        from gpiozero import Servo

        servo = Servo(17)

        servo.value = 0.5

    :type pin: int or str
    :param pin:
        The GPIO pin that the servo is connected to. See :ref:`pin-numbering`
        for valid pin numbers. If this is :data:`None` a :exc:`GPIODeviceError`
        will be raised.

    :param float initial_value:
        If ``0`` (the default), the device's mid-point will be set initially.
        Other values between -1 and +1 can be specified as an initial position.
        :data:`None` means to start the servo un-controlled (see
        :attr:`value`).

    :param float min_pulse_width:
        The pulse width corresponding to the servo's minimum position. This
        defaults to 1ms.

    :param float max_pulse_width:
        The pulse width corresponding to the servo's maximum position. This
        defaults to 2ms.

    :param float frame_width:
        The length of time between servo control pulses measured in seconds.
        This defaults to 20ms which is a common value for servos.

    :type pin_factory: Factory or None
    :param pin_factory:
        See :doc:`api_pins` for more information (this is an advanced feature
        which most users can ignore).
    """
    def __init__(self, pin=..., initial_value=..., min_pulse_width=..., max_pulse_width=..., frame_width=..., pin_factory=...) -> None:
        ...
    
    @property
    def frame_width(self): # -> Unknown:
        """
        The time between control pulses, measured in seconds.
        """
        ...
    
    @property
    def min_pulse_width(self):
        """
        The control pulse width corresponding to the servo's minimum position,
        measured in seconds.
        """
        ...
    
    @property
    def max_pulse_width(self):
        """
        The control pulse width corresponding to the servo's maximum position,
        measured in seconds.
        """
        ...
    
    @property
    def pulse_width(self): # -> None:
        """
        Returns the current pulse width controlling the servo.
        """
        ...
    
    def min(self): # -> None:
        """
        Set the servo to its minimum position.
        """
        ...
    
    def mid(self): # -> None:
        """
        Set the servo to its mid-point position.
        """
        ...
    
    def max(self): # -> None:
        """
        Set the servo to its maximum position.
        """
        ...
    
    def detach(self): # -> None:
        """
        Temporarily disable control of the servo. This is equivalent to
        setting :attr:`value` to :data:`None`.
        """
        ...
    
    @property
    def value(self): # -> None:
        """
        Represents the position of the servo as a value between -1 (the minimum
        position) and +1 (the maximum position). This can also be the special
        value :data:`None` indicating that the servo is currently
        "uncontrolled", i.e. that no control signal is being sent. Typically
        this means the servo's position remains unchanged, but that it can be
        moved by hand.
        """
        ...
    
    @value.setter
    def value(self, value): # -> None:
        ...
    
    @property
    def is_active(self): # -> bool:
        ...
    


class AngularServo(Servo):
    """
    Extends :class:`Servo` and represents a rotational PWM-controlled servo
    motor which can be set to particular angles (assuming valid minimum and
    maximum angles are provided to the constructor).

    Connect a power source (e.g. a battery pack or the 5V pin) to the power
    cable of the servo (this is typically colored red); connect the ground
    cable of the servo (typically colored black or brown) to the negative of
    your battery pack, or a GND pin; connect the final cable (typically colored
    white or orange) to the GPIO pin you wish to use for controlling the servo.

    Next, calibrate the angles that the servo can rotate to. In an interactive
    Python session, construct a :class:`Servo` instance. The servo should move
    to its mid-point by default. Set the servo to its minimum value, and
    measure the angle from the mid-point. Set the servo to its maximum value,
    and again measure the angle::

        >>> from gpiozero import Servo
        >>> s = Servo(17)
        >>> s.min() # measure the angle
        >>> s.max() # measure the angle

    You should now be able to construct an :class:`AngularServo` instance
    with the correct bounds::

        >>> from gpiozero import AngularServo
        >>> s = AngularServo(17, min_angle=-42, max_angle=44)
        >>> s.angle = 0.0
        >>> s.angle
        0.0
        >>> s.angle = 15
        >>> s.angle
        15.0

    .. note::

        You can set *min_angle* greater than *max_angle* if you wish to reverse
        the sense of the angles (e.g. ``min_angle=45, max_angle=-45``). This
        can be useful with servos that rotate in the opposite direction to your
        expectations of minimum and maximum.

    :type pin: int or str
    :param pin:
        The GPIO pin that the servo is connected to. See :ref:`pin-numbering`
        for valid pin numbers. If this is :data:`None` a :exc:`GPIODeviceError`
        will be raised.

    :param float initial_angle:
        Sets the servo's initial angle to the specified value. The default is
        0. The value specified must be between *min_angle* and *max_angle*
        inclusive. :data:`None` means to start the servo un-controlled (see
        :attr:`value`).

    :param float min_angle:
        Sets the minimum angle that the servo can rotate to. This defaults to
        -90, but should be set to whatever you measure from your servo during
        calibration.

    :param float max_angle:
        Sets the maximum angle that the servo can rotate to. This defaults to
        90, but should be set to whatever you measure from your servo during
        calibration.

    :param float min_pulse_width:
        The pulse width corresponding to the servo's minimum position. This
        defaults to 1ms.

    :param float max_pulse_width:
        The pulse width corresponding to the servo's maximum position. This
        defaults to 2ms.

    :param float frame_width:
        The length of time between servo control pulses measured in seconds.
        This defaults to 20ms which is a common value for servos.

    :type pin_factory: Factory or None
    :param pin_factory:
        See :doc:`api_pins` for more information (this is an advanced feature
        which most users can ignore).
    """
    def __init__(self, pin=..., initial_angle=..., min_angle=..., max_angle=..., min_pulse_width=..., max_pulse_width=..., frame_width=..., pin_factory=...) -> None:
        ...
    
    @property
    def min_angle(self): # -> Unknown:
        """
        The minimum angle that the servo will rotate to when :meth:`min` is
        called.
        """
        ...
    
    @property
    def max_angle(self):
        """
        The maximum angle that the servo will rotate to when :meth:`max` is
        called.
        """
        ...
    
    @property
    def angle(self): # -> None:
        """
        The position of the servo as an angle measured in degrees. This will
        only be accurate if :attr:`min_angle` and :attr:`max_angle` have been
        set appropriately in the constructor.

        This can also be the special value :data:`None` indicating that the
        servo is currently "uncontrolled", i.e. that no control signal is being
        sent.  Typically this means the servo's position remains unchanged, but
        that it can be moved by hand.
        """
        ...
    
    @angle.setter
    def angle(self, angle): # -> None:
        ...
    


