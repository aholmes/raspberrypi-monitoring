"""
This type stub file was generated by pyright.
"""

from .mixins import ValuesMixin

nstr = str
str = ...
class GPIOMeta(type):
    def __new__(mcls, name, bases, cls_dict):
        ...
    
    def __call__(cls, *args, **kwargs):
        ...
    


class GPIOBase(GPIOMeta(nstr('GPIOBase'), (), {})):
    def __setattr__(self, name, value): # -> None:
        ...
    
    def __del__(self): # -> None:
        ...
    
    def close(self): # -> None:
        """
        Shut down the device and release all associated resources. This method
        can be called on an already closed device without raising an exception.

        This method is primarily intended for interactive use at the command
        line. It disables the device and releases its pin(s) for use by another
        device.

        You can attempt to do this simply by deleting an object, but unless
        you've cleaned up all references to the object this may not work (even
        if you've cleaned up all references, there's still no guarantee the
        garbage collector will actually delete the object at that point).  By
        contrast, the close method provides a means of ensuring that the object
        is shut down.

        For example, if you have a breadboard with a buzzer connected to pin
        16, but then wish to attach an LED instead:

            >>> from gpiozero import *
            >>> bz = Buzzer(16)
            >>> bz.on()
            >>> bz.off()
            >>> bz.close()
            >>> led = LED(16)
            >>> led.blink()

        :class:`Device` descendents can also be used as context managers using
        the :keyword:`with` statement. For example:

            >>> from gpiozero import *
            >>> with Buzzer(16) as bz:
            ...     bz.on()
            ...
            >>> with LED(16) as led:
            ...     led.on()
            ...
        """
        ...
    
    @property
    def closed(self):
        """
        Returns :data:`True` if the device is closed (see the :meth:`close`
        method). Once a device is closed you can no longer use any other
        methods or properties to control or query the device.
        """
        ...
    
    def __enter__(self): # -> Self@GPIOBase:
        ...
    
    def __exit__(self, exc_type, exc_value, exc_tb): # -> None:
        ...
    


class Device(ValuesMixin, GPIOBase):
    """
    Represents a single device of any type; GPIO-based, SPI-based, I2C-based,
    etc. This is the base class of the device hierarchy. It defines the basic
    services applicable to all devices (specifically the :attr:`is_active`
    property, the :attr:`value` property, and the :meth:`close` method).

    .. attribute:: pin_factory

        This attribute exists at both a class level (representing the default
        pin factory used to construct devices when no *pin_factory* parameter
        is specified), and at an instance level (representing the pin factory
        that the device was constructed with).

        The pin factory provides various facilities to the device including
        allocating pins, providing low level interfaces (e.g. SPI), and clock
        facilities (querying and calculating elapsed times).
    """
    pin_factory = ...
    def __init__(self, **kwargs) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    @property
    def value(self) -> int:
        """
        Returns a value representing the device's state. Frequently, this is a
        boolean value, or a number between 0 and 1 but some devices use larger
        ranges (e.g. -1 to +1) and composite devices usually use tuples to
        return the states of all their subordinate components.
        """
        ...
    
    @property
    def is_active(self): # -> bool:
        """
        Returns :data:`True` if the device is currently active and
        :data:`False` otherwise. This property is usually derived from
        :attr:`value`. Unlike :attr:`value`, this is *always* a boolean.
        """
        ...
    


class CompositeDevice(Device):
    """
    Extends :class:`Device`. Represents a device composed of multiple devices
    like simple HATs, H-bridge motor controllers, robots composed of multiple
    motors, etc.

    The constructor accepts subordinate devices as positional or keyword
    arguments.  Positional arguments form unnamed devices accessed by treating
    the composite device as a container, while keyword arguments are added to
    the device as named (read-only) attributes.

    For example:

    .. code-block:: pycon

        >>> from gpiozero import *
        >>> d = CompositeDevice(LED(2), LED(3), LED(4), btn=Button(17))
        >>> d[0]
        <gpiozero.LED object on pin GPIO2, active_high=True, is_active=False>
        >>> d[1]
        <gpiozero.LED object on pin GPIO3, active_high=True, is_active=False>
        >>> d[2]
        <gpiozero.LED object on pin GPIO4, active_high=True, is_active=False>
        >>> d.btn
        <gpiozero.Button object on pin GPIO17, pull_up=True, is_active=False>
        >>> d.value
        CompositeDeviceValue(device_0=False, device_1=False, device_2=False, btn=False)

    :param Device \\*args:
        The un-named devices that belong to the composite device. The
        :attr:`value` attributes of these devices will be represented within
        the composite device's tuple :attr:`value` in the order specified here.

    :type _order: list or None
    :param _order:
        If specified, this is the order of named items specified by keyword
        arguments (to ensure that the :attr:`value` tuple is constructed with a
        specific order). All keyword arguments *must* be included in the
        collection. If omitted, an alphabetically sorted order will be selected
        for keyword arguments.

    :type pin_factory: Factory or None
    :param pin_factory:
        See :doc:`api_pins` for more information (this is an advanced feature
        which most users can ignore).

    :param Device \\*\\*kwargs:
        The named devices that belong to the composite device. These devices
        will be accessible as named attributes on the resulting device, and
        their :attr:`value` attributes will be accessible as named elements of
        the composite device's tuple :attr:`value`.
    """
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def __getattr__(self, name): # -> frozendict:
        ...
    
    def __setattr__(self, name, value): # -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __len__(self): # -> int:
        ...
    
    def __getitem__(self, index): # -> Any:
        ...
    
    def __iter__(self): # -> Iterator[Any]:
        ...
    
    @property
    def all(self): # -> tuple[()] | tuple[Unknown, ...]:
        ...
    
    def close(self): # -> None:
        ...
    
    @property
    def closed(self): # -> bool:
        ...
    
    @property
    def namedtuple(self): # -> Type[namedtuple] | None:
        """
        The :func:`~collections.namedtuple` type constructed to represent the
        value of the composite device. The :attr:`value` attribute returns
        values of this type.
        """
        ...
    
    @property
    def value(self): # -> Self@namedtuple:
        """
        A :func:`~collections.namedtuple` containing a value for each
        subordinate device. Devices with names will be represented as named
        elements. Unnamed devices will have a unique name generated for them,
        and they will appear in the position they appeared in the constructor.
        """
        ...
    
    @property
    def is_active(self): # -> bool:
        """
        Composite devices are considered "active" if any of their constituent
        devices have a "truthy" value.
        """
        ...
    


class GPIODevice(Device):
    """
    Extends :class:`Device`. Represents a generic GPIO device and provides
    the services common to all single-pin GPIO devices (like ensuring two
    GPIO devices do no share a :attr:`pin`).

    :type pin: int or str
    :param pin:
        The GPIO pin that the device is connected to. See :ref:`pin-numbering`
        for valid pin numbers. If this is :data:`None` a :exc:`GPIODeviceError`
        will be raised. If the pin is already in use by another device,
        :exc:`GPIOPinInUse` will be raised.
    """
    def __init__(self, pin=..., **kwargs) -> None:
        ...
    
    def close(self): # -> None:
        ...
    
    @property
    def closed(self): # -> bool:
        ...
    
    @property
    def pin(self): # -> Any | None:
        """
        The :class:`Pin` that the device is connected to. This will be
        :data:`None` if the device has been closed (see the
        :meth:`~Device.close` method). When dealing with GPIO pins, query
        ``pin.number`` to discover the GPIO pin (in BCM numbering) that the
        device is connected to.
        """
        ...
    
    @property
    def value(self): # -> int:
        ...
    
    def __repr__(self): # -> str:
        ...
    


