"""
This type stub file was generated by pyright.
"""

from .output_devices import RGBLED
from .devices import CompositeDevice, Device
from .mixins import HoldMixin, SharedMixin, SourceMixin

class CompositeOutputDevice(SourceMixin, CompositeDevice):
    """
    Extends :class:`CompositeDevice` with :meth:`on`, :meth:`off`, and
    :meth:`toggle` methods for controlling subordinate output devices.  Also
    extends :attr:`value` to be writeable.

    :param Device \\*args:
        The un-named devices that belong to the composite device. The
        :attr:`~Device.value` attributes of these devices will be represented
        within the composite device's tuple :attr:`value` in the order
        specified here.

    :type _order: list or None
    :param _order:
        If specified, this is the order of named items specified by keyword
        arguments (to ensure that the :attr:`value` tuple is constructed with a
        specific order). All keyword arguments *must* be included in the
        collection. If omitted, an alphabetically sorted order will be selected
        for keyword arguments.

    :type pin_factory: Factory or None
    :param pin_factory:
        See :doc:`api_pins` for more information (this is an advanced feature
        which most users can ignore).

    :param Device \\*\\*kwargs:
        The named devices that belong to the composite device. These devices
        will be accessible as named attributes on the resulting device, and
        their :attr:`value` attributes will be accessible as named elements of
        the composite device's tuple :attr:`value`.
    """
    def on(self): # -> None:
        """
        Turn all the output devices on.
        """
        ...
    
    def off(self): # -> None:
        """
        Turn all the output devices off.
        """
        ...
    
    def toggle(self): # -> None:
        """
        Toggle all the output devices. For each device, if it's on, turn it
        off; if it's off, turn it on.
        """
        ...
    
    @property
    def value(self):
        """
        A tuple containing a value for each subordinate device. This property
        can also be set to update the state of all subordinate output devices.
        """
        ...
    
    @value.setter
    def value(self, value): # -> None:
        ...
    


class ButtonBoard(HoldMixin, CompositeDevice):
    """
    Extends :class:`CompositeDevice` and represents a generic button board or
    collection of buttons. The :attr:`value` of the button board is a tuple
    of all the buttons states. This can be used to control all the LEDs in a
    :class:`LEDBoard` with a :class:`ButtonBoard`::

        from gpiozero import LEDBoard, ButtonBoard
        from signal import pause

        leds = LEDBoard(2, 3, 4, 5)
        btns = ButtonBoard(6, 7, 8, 9)
        leds.source = btns.values
        pause()

    Alternatively you could represent the number of pressed buttons with an
    :class:`LEDBarGraph`::

        from gpiozero import LEDBarGraph, ButtonBoard
        from signal import pause

        graph = LEDBarGraph(2, 3, 4, 5)
        btns = ButtonBoard(6, 7, 8, 9)
        graph.source = (sum(value) for value in btn.values)
        pause()

    :type pins: int or str
    :param \\*pins:
        Specify the GPIO pins that the buttons of the board are attached to.
        See :ref:`pin-numbering` for valid pin numbers. You can designate as
        many pins as necessary.

    :type pull_up: bool or None
    :param pull_up:
        If :data:`True` (the default), the GPIO pins will be pulled high by
        default.  In this case, connect the other side of the buttons to
        ground.  If :data:`False`, the GPIO pins will be pulled low by default.
        In this case, connect the other side of the buttons to 3V3. If
        :data:`None`, the pin will be floating, so it must be externally pulled
        up or down and the ``active_state`` parameter must be set accordingly.

    :type active_state: bool or None
    :param active_state:
        See description under :class:`InputDevice` for more information.

    :param float bounce_time:
        If :data:`None` (the default), no software bounce compensation will be
        performed. Otherwise, this is the length of time (in seconds) that the
        buttons will ignore changes in state after an initial change.

    :param float hold_time:
        The length of time (in seconds) to wait after any button is pushed,
        until executing the :attr:`when_held` handler. Defaults to ``1``.

    :param bool hold_repeat:
        If :data:`True`, the :attr:`when_held` handler will be repeatedly
        executed as long as any buttons remain held, every *hold_time* seconds.
        If :data:`False` (the default) the :attr:`when_held` handler will be
        only be executed once per hold.

    :type pin_factory: Factory or None
    :param pin_factory:
        See :doc:`api_pins` for more information (this is an advanced feature
        which most users can ignore).

    :type named_pins: int or str
    :param \\*\\*named_pins:
        Specify GPIO pins that buttons of the board are attached to,
        associating each button with a property name. You can designate as
        many pins as necessary and use any names, provided they're not already
        in use by something else.
    """
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @property
    def pull_up(self): # -> Any:
        """
        If :data:`True`, the device uses a pull-up resistor to set the GPIO pin
        "high" by default.
        """
        ...
    
    @property
    def when_changed(self): # -> None:
        ...
    
    @when_changed.setter
    def when_changed(self, value): # -> None:
        ...
    


class LEDCollection(CompositeOutputDevice):
    """
    Extends :class:`CompositeOutputDevice`. Abstract base class for
    :class:`LEDBoard` and :class:`LEDBarGraph`.
    """
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @property
    def leds(self): # -> tuple[Unknown, ...]:
        """
        A flat tuple of all LEDs contained in this collection (and all
        sub-collections).
        """
        ...
    
    @property
    def active_high(self): # -> Any:
        ...
    


class LEDBoard(LEDCollection):
    """
    Extends :class:`LEDCollection` and represents a generic LED board or
    collection of LEDs.

    The following example turns on all the LEDs on a board containing 5 LEDs
    attached to GPIO pins 2 through 6::

        from gpiozero import LEDBoard

        leds = LEDBoard(2, 3, 4, 5, 6)
        leds.on()

    :type pins: int or str or LEDCollection
    :param \\*pins:
        Specify the GPIO pins that the LEDs of the board are attached to. See
        :ref:`pin-numbering` for valid pin numbers. You can designate as many
        pins as necessary. You can also specify :class:`LEDBoard` instances to
        create trees of LEDs.

    :param bool pwm:
        If :data:`True`, construct :class:`PWMLED` instances for each pin. If
        :data:`False` (the default), construct regular :class:`LED` instances.

    :param bool active_high:
        If :data:`True` (the default), the :meth:`on` method will set all the
        associated pins to HIGH. If :data:`False`, the :meth:`on` method will
        set all pins to LOW (the :meth:`off` method always does the opposite).

    :type initial_value: bool or None
    :param initial_value:
        If :data:`False` (the default), all LEDs will be off initially. If
        :data:`None`, each device will be left in whatever state the pin is
        found in when configured for output (warning: this can be on). If
        :data:`True`, the device will be switched on initially.

    :type pin_factory: Factory or None
    :param pin_factory:
        See :doc:`api_pins` for more information (this is an advanced feature
        which most users can ignore).

    :type named_pins: int or str
    :param \\*\\*named_pins:
        Specify GPIO pins that LEDs of the board are attached to, associating
        each LED with a property name. You can designate as many pins as
        necessary and use any names, provided they're not already in use by
        something else. You can also specify :class:`LEDBoard` instances to
        create trees of LEDs.
    """
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def close(self): # -> None:
        ...
    
    def on(self, *args): # -> None:
        """
        If no arguments are specified, turn all the LEDs on. If arguments are
        specified, they must be the indexes of the LEDs you wish to turn on.
        For example::

            from gpiozero import LEDBoard

            leds = LEDBoard(2, 3, 4, 5)
            leds.on(0)    # turn on the first LED (pin 2)
            leds.on(-1)   # turn on the last LED (pin 5)
            leds.on(1, 2) # turn on the middle LEDs (pins 3 and 4)
            leds.off()    # turn off all LEDs
            leds.on()     # turn on all LEDs

        If :meth:`blink` is currently active, it will be stopped first.

        :param int args:
            The index(es) of the LED(s) to turn on. If no indexes are specified
            turn on all LEDs.
        """
        ...
    
    def off(self, *args): # -> None:
        """
        If no arguments are specified, turn all the LEDs off. If arguments are
        specified, they must be the indexes of the LEDs you wish to turn off.
        For example::

            from gpiozero import LEDBoard

            leds = LEDBoard(2, 3, 4, 5)
            leds.on()      # turn on all LEDs
            leds.off(0)    # turn off the first LED (pin 2)
            leds.off(-1)   # turn off the last LED (pin 5)
            leds.off(1, 2) # turn off the middle LEDs (pins 3 and 4)
            leds.on()      # turn on all LEDs

        If :meth:`blink` is currently active, it will be stopped first.

        :param int args:
            The index(es) of the LED(s) to turn off. If no indexes are
            specified turn off all LEDs.
        """
        ...
    
    def toggle(self, *args): # -> None:
        """
        If no arguments are specified, toggle the state of all LEDs. If
        arguments are specified, they must be the indexes of the LEDs you wish
        to toggle. For example::

            from gpiozero import LEDBoard

            leds = LEDBoard(2, 3, 4, 5)
            leds.toggle(0)   # turn on the first LED (pin 2)
            leds.toggle(-1)  # turn on the last LED (pin 5)
            leds.toggle()    # turn the first and last LED off, and the
                             # middle pair on

        If :meth:`blink` is currently active, it will be stopped first.

        :param int args:
            The index(es) of the LED(s) to toggle. If no indexes are specified
            toggle the state of all LEDs.
        """
        ...
    
    def blink(self, on_time=..., off_time=..., fade_in_time=..., fade_out_time=..., n=..., background=...): # -> None:
        """
        Make all the LEDs turn on and off repeatedly.

        :param float on_time:
            Number of seconds on. Defaults to 1 second.

        :param float off_time:
            Number of seconds off. Defaults to 1 second.

        :param float fade_in_time:
            Number of seconds to spend fading in. Defaults to 0. Must be 0 if
            ``pwm`` was :data:`False` when the class was constructed
            (:exc:`ValueError` will be raised if not).

        :param float fade_out_time:
            Number of seconds to spend fading out. Defaults to 0. Must be 0 if
            ``pwm`` was :data:`False` when the class was constructed
            (:exc:`ValueError` will be raised if not).

        :type n: int or None
        :param n:
            Number of times to blink; :data:`None` (the default) means forever.

        :param bool background:
            If :data:`True`, start a background thread to continue blinking and
            return immediately. If :data:`False`, only return when the blink is
            finished (warning: the default value of *n* will result in this
            method never returning).
        """
        ...
    
    def pulse(self, fade_in_time=..., fade_out_time=..., n=..., background=...): # -> None:
        """
        Make all LEDs fade in and out repeatedly. Note that this method will
        only work if the *pwm* parameter was :data:`True` at construction time.

        :param float fade_in_time:
            Number of seconds to spend fading in. Defaults to 1.

        :param float fade_out_time:
            Number of seconds to spend fading out. Defaults to 1.

        :type n: int or None
        :param n:
            Number of times to blink; :data:`None` (the default) means forever.

        :param bool background:
            If :data:`True` (the default), start a background thread to
            continue blinking and return immediately. If :data:`False`, only
            return when the blink is finished (warning: the default value of
            *n* will result in this method never returning).
        """
        ...
    


class LEDBarGraph(LEDCollection):
    """
    Extends :class:`LEDCollection` to control a line of LEDs representing a
    bar graph. Positive values (0 to 1) light the LEDs from first to last.
    Negative values (-1 to 0) light the LEDs from last to first.

    The following example demonstrates turning on the first two and last two
    LEDs in a board containing five LEDs attached to GPIOs 2 through 6::

        from gpiozero import LEDBarGraph
        from time import sleep

        graph = LEDBarGraph(2, 3, 4, 5, 6)
        graph.value = 2/5  # Light the first two LEDs only
        sleep(1)
        graph.value = -2/5 # Light the last two LEDs only
        sleep(1)
        graph.off()

    As with all other output devices, :attr:`source` and :attr:`values` are
    supported::

        from gpiozero import LEDBarGraph, MCP3008
        from signal import pause

        graph = LEDBarGraph(2, 3, 4, 5, 6, pwm=True)
        pot = MCP3008(channel=0)

        graph.source = pot

        pause()

    :type pins: int or str
    :param \\*pins:
        Specify the GPIO pins that the LEDs of the bar graph are attached to.
        See :ref:`pin-numbering` for valid pin numbers. You can designate as
        many pins as necessary.

    :param bool pwm:
        If :data:`True`, construct :class:`PWMLED` instances for each pin. If
        :data:`False` (the default), construct regular :class:`LED` instances.
        This parameter can only be specified as a keyword parameter.

    :param bool active_high:
        If :data:`True` (the default), the :meth:`on` method will set all the
        associated pins to HIGH. If :data:`False`, the :meth:`on` method will
        set all pins to LOW (the :meth:`off` method always does the opposite).
        This parameter can only be specified as a keyword parameter.

    :param float initial_value:
        The initial :attr:`value` of the graph given as a float between -1 and
        +1. Defaults to 0.0. This parameter can only be specified as a
        keyword parameter.

    :type pin_factory: Factory or None
    :param pin_factory:
        See :doc:`api_pins` for more information (this is an advanced feature
        which most users can ignore).
    """
    def __init__(self, *pins, **kwargs) -> None:
        ...
    
    @property
    def value(self): # -> Any | float:
        """
        The value of the LED bar graph. When no LEDs are lit, the value is 0.
        When all LEDs are lit, the value is 1. Values between 0 and 1
        light LEDs linearly from first to last. Values between 0 and -1
        light LEDs linearly from last to first.

        To light a particular number of LEDs, simply divide that number by
        the number of LEDs. For example, if your graph contains 3 LEDs, the
        following will light the first::

            from gpiozero import LEDBarGraph

            graph = LEDBarGraph(12, 16, 19)
            graph.value = 1/3

        .. note::

            Setting value to -1 will light all LEDs. However, querying it
            subsequently will return 1 as both representations are the same in
            hardware. The readable range of :attr:`value` is effectively
            -1 < value <= 1.
        """
        ...
    
    @value.setter
    def value(self, value): # -> None:
        ...
    
    @property
    def lit_count(self): # -> int | Any | float:
        """
        The number of LEDs on the bar graph actually lit up. Note that just
        like :attr:`value`, this can be negative if the LEDs are lit from last
        to first.
        """
        ...
    
    @lit_count.setter
    def lit_count(self, value): # -> None:
        ...
    


class PiHutXmasTree(LEDBoard):
    """
    Extends :class:`LEDBoard` for `The Pi Hut's Xmas board`_: a 3D Christmas
    tree board with 24 red LEDs and a white LED as a star on top.

    The 24 red LEDs can be accessed through the attributes led0, led1, led2,
    and so on. The white star LED is accessed through the :attr:`star`
    attribute. Alternatively, as with all descendents of :class:`LEDBoard`,
    you can treat the instance as a sequence of LEDs (the first element is the
    :attr:`star`).

    The Xmas Tree board pins are fixed and therefore there's no need to specify
    them when constructing this class. The following example turns all the LEDs
    on one at a time::

        from gpiozero import PiHutXmasTree
        from time import sleep

        tree = PiHutXmasTree()

        for light in tree:
            light.on()
            sleep(1)

    The following example turns the star LED on and sets all the red LEDs to
    flicker randomly::

        from gpiozero import PiHutXmasTree
        from gpiozero.tools import random_values
        from signal import pause

        tree = PiHutXmasTree(pwm=True)

        tree.star.on()

        for led in tree[1:]:
            led.source_delay = 0.1
            led.source = random_values()

        pause()

    :param bool pwm:
        If :data:`True`, construct :class:`PWMLED` instances for each pin. If
        :data:`False` (the default), construct regular :class:`LED` instances.

    :type initial_value: bool or None
    :param initial_value:
        If :data:`False` (the default), all LEDs will be off initially. If
        :data:`None`, each device will be left in whatever state the pin is
        found in when configured for output (warning: this can be on). If
        :data:`True`, the device will be switched on initially.

    :type pin_factory: Factory or None
    :param pin_factory:
        See :doc:`api_pins` for more information (this is an advanced feature
        which most users can ignore).

    .. _The Pi Hut's Xmas board: https://thepihut.com/xmas

    .. attribute:: star

        Returns the :class:`LED` or :class:`PWMLED` representing the white
        star on top of the tree.

    .. attribute:: led0, led1, led2, ...

        Returns the :class:`LED` or :class:`PWMLED` representing one of the red
        LEDs. There are actually 24 of these properties named led0, led1, and
        so on but for the sake of brevity we represent all 24 under this
        section.
    """
    def __init__(self, pwm=..., initial_value=..., pin_factory=...) -> None:
        ...
    


class LedBorg(RGBLED):
    """
    Extends :class:`RGBLED` for the `PiBorg LedBorg`_: an add-on board
    containing a very bright RGB LED.

    The LedBorg pins are fixed and therefore there's no need to specify them
    when constructing this class. The following example turns the LedBorg
    purple::

        from gpiozero import LedBorg

        led = LedBorg()
        led.color = (1, 0, 1)

    :type initial_value: ~colorzero.Color or tuple
    :param initial_value:
        The initial color for the LedBorg. Defaults to black ``(0, 0, 0)``.

    :param bool pwm:
        If :data:`True` (the default), construct :class:`PWMLED` instances for
        each component of the LedBorg. If :data:`False`, construct regular
        :class:`LED` instances, which prevents smooth color graduations.

    :type pin_factory: Factory or None
    :param pin_factory:
        See :doc:`api_pins` for more information (this is an advanced feature
        which most users can ignore).

    .. _PiBorg LedBorg: https://www.piborg.org/ledborg
    """
    def __init__(self, initial_value=..., pwm=..., pin_factory=...) -> None:
        ...
    


class PiLiter(LEDBoard):
    """
    Extends :class:`LEDBoard` for the `Ciseco Pi-LITEr`_: a strip of 8 very
    bright LEDs.

    The Pi-LITEr pins are fixed and therefore there's no need to specify them
    when constructing this class. The following example turns on all the LEDs
    of the Pi-LITEr::

        from gpiozero import PiLiter

        lite = PiLiter()
        lite.on()

    :param bool pwm:
        If :data:`True`, construct :class:`PWMLED` instances for each pin. If
        :data:`False` (the default), construct regular :class:`LED` instances.

    :type initial_value: bool or None
    :param initial_value:
        If :data:`False` (the default), all LEDs will be off initially. If
        :data:`None`, each LED will be left in whatever state the pin is found
        in when configured for output (warning: this can be on). If
        :data:`True`, the each LED will be switched on initially.

    :type pin_factory: Factory or None
    :param pin_factory:
        See :doc:`api_pins` for more information (this is an advanced feature
        which most users can ignore).

    .. _Ciseco Pi-LITEr: http://shop.ciseco.co.uk/pi-liter-8-led-strip-for-the-raspberry-pi/
    """
    def __init__(self, pwm=..., initial_value=..., pin_factory=...) -> None:
        ...
    


class PiLiterBarGraph(LEDBarGraph):
    """
    Extends :class:`LEDBarGraph` to treat the `Ciseco Pi-LITEr`_ as an
    8-segment bar graph.

    The Pi-LITEr pins are fixed and therefore there's no need to specify them
    when constructing this class. The following example sets the graph value
    to 0.5::

        from gpiozero import PiLiterBarGraph

        graph = PiLiterBarGraph()
        graph.value = 0.5

    :param bool pwm:
        If :data:`True`, construct :class:`PWMLED` instances for each pin. If
        :data:`False` (the default), construct regular :class:`LED` instances.

    :param float initial_value:
        The initial :attr:`value` of the graph given as a float between -1 and
        +1. Defaults to ``0.0``.

    :type pin_factory: Factory or None
    :param pin_factory:
        See :doc:`api_pins` for more information (this is an advanced feature
        which most users can ignore).

    .. _Ciseco Pi-LITEr: http://shop.ciseco.co.uk/pi-liter-8-led-strip-for-the-raspberry-pi/
    """
    def __init__(self, pwm=..., initial_value=..., pin_factory=...) -> None:
        ...
    


class TrafficLights(LEDBoard):
    """
    Extends :class:`LEDBoard` for devices containing red, yellow, and green
    LEDs.

    The following example initializes a device connected to GPIO pins 2, 3,
    and 4, then lights the amber (yellow) LED attached to GPIO 3::

        from gpiozero import TrafficLights

        traffic = TrafficLights(2, 3, 4)
        traffic.amber.on()

    :type red: int or str
    :param red:
        The GPIO pin that the red LED is attached to. See :ref:`pin-numbering`
        for valid pin numbers.

    :type amber: int or str or None
    :param amber:
        The GPIO pin that the amber LED is attached to. See
        :ref:`pin-numbering` for valid pin numbers.

    :type yellow: int or str or None
    :param yellow:
        The GPIO pin that the yellow LED is attached to. This is merely an
        alias for the ``amber`` parameter; you can't specify both ``amber`` and
        ``yellow``. See :ref:`pin-numbering` for valid pin numbers.

    :type green: int or str
    :param green:
        The GPIO pin that the green LED is attached to. See
        :ref:`pin-numbering` for valid pin numbers.

    :param bool pwm:
        If :data:`True`, construct :class:`PWMLED` instances to represent each
        LED. If :data:`False` (the default), construct regular :class:`LED`
        instances.

    :type initial_value: bool or None
    :param initial_value:
        If :data:`False` (the default), all LEDs will be off initially. If
        :data:`None`, each device will be left in whatever state the pin is
        found in when configured for output (warning: this can be on). If
        :data:`True`, the device will be switched on initially.

    :type pin_factory: Factory or None
    :param pin_factory:
        See :doc:`api_pins` for more information (this is an advanced feature
        which most users can ignore).

    .. attribute:: red

        The red :class:`LED` or :class:`PWMLED`.

    .. attribute:: amber

        The amber :class:`LED` or :class:`PWMLED`. Note that this attribute
        will not be present when the instance is constructed with the
        *yellow* keyword parameter.

    .. attribute:: yellow

        The yellow :class:`LED` or :class:`PWMLED`. Note that this attribute
        will only be present when the instance is constructed with the
        *yellow* keyword parameter.

    .. attribute:: green

        The green :class:`LED` or :class:`PWMLED`.
    """
    def __init__(self, red=..., amber=..., green=..., pwm=..., initial_value=..., yellow=..., pin_factory=...) -> None:
        ...
    
    def __getattr__(self, name): # -> frozendict:
        ...
    


class PiTraffic(TrafficLights):
    """
    Extends :class:`TrafficLights` for the `Low Voltage Labs PI-TRAFFIC`_
    vertical traffic lights board when attached to GPIO pins 9, 10, and 11.

    There's no need to specify the pins if the PI-TRAFFIC is connected to the
    default pins (9, 10, 11). The following example turns on the amber LED on
    the PI-TRAFFIC::

        from gpiozero import PiTraffic

        traffic = PiTraffic()
        traffic.amber.on()

    To use the PI-TRAFFIC board when attached to a non-standard set of pins,
    simply use the parent class, :class:`TrafficLights`.

    :param bool pwm:
        If :data:`True`, construct :class:`PWMLED` instances to represent each
        LED. If :data:`False` (the default), construct regular :class:`LED`
        instances.

    :type initial_value: bool or None
    :param bool initial_value:
        If :data:`False` (the default), all LEDs will be off initially. If
        :data:`None`, each device will be left in whatever state the pin is
        found in when configured for output (warning: this can be on). If
        :data:`True`, the device will be switched on initially.

    :type pin_factory: Factory or None
    :param pin_factory:
        See :doc:`api_pins` for more information (this is an advanced feature
        which most users can ignore).

    .. _Low Voltage Labs PI-TRAFFIC: http://lowvoltagelabs.com/products/pi-traffic/
    """
    def __init__(self, pwm=..., initial_value=..., pin_factory=...) -> None:
        ...
    


class PiStop(TrafficLights):
    """
    Extends :class:`TrafficLights` for the `PiHardware Pi-Stop`_: a vertical
    traffic lights board.

    The following example turns on the amber LED on a Pi-Stop connected to
    location ``A+``::

        from gpiozero import PiStop

        traffic = PiStop('A+')
        traffic.amber.on()

    :param str location:
        The `location`_ on the GPIO header to which the Pi-Stop is connected.
        Must be one of: ``A``, ``A+``, ``B``, ``B+``, ``C``, ``D``.

    :param bool pwm:
        If :data:`True`, construct :class:`PWMLED` instances to represent each
        LED. If :data:`False` (the default), construct regular :class:`LED`
        instances.

    :type initial_value: bool or None
    :param bool initial_value:
        If :data:`False` (the default), all LEDs will be off initially. If
        :data:`None`, each device will be left in whatever state the pin is
        found in when configured for output (warning: this can be on). If
        :data:`True`, the device will be switched on initially.

    :type pin_factory: Factory or None
    :param pin_factory:
        See :doc:`api_pins` for more information (this is an advanced feature
        which most users can ignore).

    .. _PiHardware Pi-Stop: https://pihw.wordpress.com/meltwaters-pi-hardware-kits/pi-stop/
    .. _location: https://github.com/PiHw/Pi-Stop/blob/master/markdown_source/markdown/Discover-PiStop.md
    """
    LOCATIONS = ...
    def __init__(self, location=..., pwm=..., initial_value=..., pin_factory=...) -> None:
        ...
    


class StatusZero(LEDBoard):
    """
    Extends :class:`LEDBoard` for The Pi Hut's `STATUS Zero`_: a Pi Zero sized
    add-on board with three sets of red/green LEDs to provide a status
    indicator.

    The following example designates the first strip the label "wifi" and the
    second "raining", and turns them green and red respectfully::

        from gpiozero import StatusZero

        status = StatusZero('wifi', 'raining')
        status.wifi.green.on()
        status.raining.red.on()

    Each designated label will contain two :class:`LED` objects named "red"
    and "green".

    :param str \\*labels:
        Specify the names of the labels you wish to designate the strips to.
        You can list up to three labels. If no labels are given, three strips
        will be initialised with names 'one', 'two', and 'three'. If some, but
        not all strips are given labels, any remaining strips will not be
        initialised.

    :type pin_factory: Factory or None
    :param pin_factory:
        See :doc:`api_pins` for more information (this is an advanced feature
        which most users can ignore).

    .. _STATUS Zero: https://thepihut.com/statuszero

    .. attribute:: your-label-here, your-label-here, ...

        This entry represents one of the three labelled attributes supported on
        the STATUS Zero board. It is an :class:`LEDBoard` which contains:

        .. attribute:: red

            The :class:`LED` or :class:`PWMLED` representing the red LED
            next to the label.

        .. attribute:: green

            The :class:`LED` or :class:`PWMLED` representing the green LED
            next to the label.
    """
    default_labels = ...
    def __init__(self, *labels, **kwargs) -> None:
        ...
    


class StatusBoard(CompositeOutputDevice):
    """
    Extends :class:`CompositeOutputDevice` for The Pi Hut's `STATUS`_ board: a
    HAT sized add-on board with five sets of red/green LEDs and buttons to
    provide a status indicator with additional input.

    The following example designates the first strip the label "wifi" and the
    second "raining", turns the wifi green and then activates the button to
    toggle its lights when pressed::

        from gpiozero import StatusBoard

        status = StatusBoard('wifi', 'raining')
        status.wifi.lights.green.on()
        status.wifi.button.when_pressed = status.wifi.lights.toggle

    Each designated label will contain a "lights" :class:`LEDBoard` containing
    two :class:`LED` objects named "red" and "green", and a :class:`Button`
    object named "button".

    :param str \\*labels:
        Specify the names of the labels you wish to designate the strips to.
        You can list up to five labels. If no labels are given, five strips
        will be initialised with names 'one' to 'five'. If some, but not all
        strips are given labels, any remaining strips will not be initialised.

    :type pin_factory: Factory or None
    :param pin_factory:
        See :doc:`api_pins` for more information (this is an advanced feature
        which most users can ignore).

    .. _STATUS: https://thepihut.com/status

    .. attribute:: your-label-here, your-label-here, ...

        This entry represents one of the five labelled attributes supported on
        the STATUS board. It is an :class:`CompositeOutputDevice` which
        contains:

        .. attribute:: lights

            A :class:`LEDBoard` representing the lights next to the label. It
            contains:

            .. attribute:: red

                The :class:`LED` or :class:`PWMLED` representing the red LED
                next to the label.

            .. attribute:: green

                The :class:`LED` or :class:`PWMLED` representing the green LED
                next to the label.

        .. attribute:: button

            A :class:`Button` representing the button next to the label.
    """
    default_labels = ...
    def __init__(self, *labels, **kwargs) -> None:
        ...
    


class SnowPi(LEDBoard):
    """
    Extends :class:`LEDBoard` for the `Ryanteck SnowPi`_ board.

    The SnowPi pins are fixed and therefore there's no need to specify them
    when constructing this class. The following example turns on the eyes, sets
    the nose pulsing, and the arms blinking::

        from gpiozero import SnowPi

        snowman = SnowPi(pwm=True)
        snowman.eyes.on()
        snowman.nose.pulse()
        snowman.arms.blink()

    :param bool pwm:
        If :data:`True`, construct :class:`PWMLED` instances to represent each
        LED. If :data:`False` (the default), construct regular :class:`LED`
        instances.

    :type initial_value: bool or None
    :param bool initial_value:
        If :data:`False` (the default), all LEDs will be off initially. If
        :data:`None`, each device will be left in whatever state the pin is
        found in when configured for output (warning: this can be on). If
        :data:`True`, the device will be switched on initially.

    :type pin_factory: Factory or None
    :param pin_factory:
        See :doc:`api_pins` for more information (this is an advanced feature
        which most users can ignore).

    .. _Ryanteck SnowPi: https://ryanteck.uk/raspberry-pi/114-snowpi-the-gpio-snowman-for-raspberry-pi-0635648608303.html

    .. attribute:: arms

        A :class:`LEDBoard` representing the arms of the snow man. It contains
        the following attributes:

        .. attribute:: left, right

            Two :class:`LEDBoard` objects representing the left and right arms
            of the snow-man. They contain:

            .. attribute:: top, middle, bottom

                The :class:`LED` or :class:`PWMLED` down the snow-man's arms.

    .. attribute:: eyes

        A :class:`LEDBoard` representing the eyes of the snow-man. It contains:

        .. attribute:: left, right

            The :class:`LED` or :class:`PWMLED` for the snow-man's eyes.

    .. attribute:: nose

        The :class:`LED` or :class:`PWMLED` for the snow-man's nose.
    """
    def __init__(self, pwm=..., initial_value=..., pin_factory=...) -> None:
        ...
    


class TrafficLightsBuzzer(CompositeOutputDevice):
    """
    Extends :class:`CompositeOutputDevice` and is a generic class for HATs with
    traffic lights, a button and a buzzer.

    :param TrafficLights lights:
        An instance of :class:`TrafficLights` representing the traffic lights
        of the HAT.

    :param Buzzer buzzer:
        An instance of :class:`Buzzer` representing the buzzer on the HAT.

    :param Button button:
        An instance of :class:`Button` representing the button on the HAT.

    :type pin_factory: Factory or None
    :param pin_factory:
        See :doc:`api_pins` for more information (this is an advanced feature
        which most users can ignore).

    .. attribute:: lights

        The :class:`TrafficLights` instance passed as the *lights* parameter.

    .. attribute:: buzzer

        The :class:`Buzzer` instance passed as the *buzzer* parameter.

    .. attribute:: button

        The :class:`Button` instance passed as the *button* parameter.
    """
    def __init__(self, lights, buzzer, button, pin_factory=...) -> None:
        ...
    


class FishDish(TrafficLightsBuzzer):
    """
    Extends :class:`TrafficLightsBuzzer` for the `Pi Supply FishDish`_: traffic
    light LEDs, a button and a buzzer.

    The FishDish pins are fixed and therefore there's no need to specify them
    when constructing this class. The following example waits for the button
    to be pressed on the FishDish, then turns on all the LEDs::

        from gpiozero import FishDish

        fish = FishDish()
        fish.button.wait_for_press()
        fish.lights.on()

    :param bool pwm:
        If :data:`True`, construct :class:`PWMLED` instances to represent each
        LED. If :data:`False` (the default), construct regular :class:`LED`
        instances.

    :type pin_factory: Factory or None
    :param pin_factory:
        See :doc:`api_pins` for more information (this is an advanced feature
        which most users can ignore).

    .. _Pi Supply FishDish: https://www.pi-supply.com/product/fish-dish-raspberry-pi-led-buzzer-board/
    """
    def __init__(self, pwm=..., pin_factory=...) -> None:
        ...
    


class TrafficHat(TrafficLightsBuzzer):
    """
    Extends :class:`TrafficLightsBuzzer` for the `Ryanteck Traffic HAT`_: traffic
    light LEDs, a button and a buzzer.

    The Traffic HAT pins are fixed and therefore there's no need to specify
    them when constructing this class. The following example waits for the
    button to be pressed on the Traffic HAT, then turns on all the LEDs::

        from gpiozero import TrafficHat

        hat = TrafficHat()
        hat.button.wait_for_press()
        hat.lights.on()

    :param bool pwm:
        If :data:`True`, construct :class:`PWMLED` instances to represent each
        LED. If :data:`False` (the default), construct regular :class:`LED`
        instances.

    :type pin_factory: Factory or None
    :param pin_factory:
        See :doc:`api_pins` for more information (this is an advanced feature
        which most users can ignore).

    .. _Ryanteck Traffic HAT: https://ryanteck.uk/hats/1-traffichat-0635648607122.html
    """
    def __init__(self, pwm=..., pin_factory=...) -> None:
        ...
    


class Robot(SourceMixin, CompositeDevice):
    """
    Extends :class:`CompositeDevice` to represent a generic dual-motor robot.

    This class is constructed with two tuples representing the forward and
    backward pins of the left and right controllers respectively. For example,
    if the left motor's controller is connected to GPIOs 4 and 14, while the
    right motor's controller is connected to GPIOs 17 and 18 then the following
    example will drive the robot forward::

        from gpiozero import Robot

        robot = Robot(left=(4, 14), right=(17, 18))
        robot.forward()

    :param tuple left:
        A tuple of two (or three) GPIO pins representing the forward and
        backward inputs of the left motor's controller. Use three pins if your
        motor controller requires an enable pin.

    :param tuple right:
        A tuple of two (or three) GPIO pins representing the forward and
        backward inputs of the right motor's controller. Use three pins if your
        motor controller requires an enable pin.

    :param bool pwm:
        If :data:`True` (the default), construct :class:`PWMOutputDevice`
        instances for the motor controller pins, allowing both direction and
        variable speed control. If :data:`False`, construct
        :class:`DigitalOutputDevice` instances, allowing only direction
        control.

    :type pin_factory: Factory or None
    :param pin_factory:
        See :doc:`api_pins` for more information (this is an advanced feature
        which most users can ignore).

    .. attribute:: left_motor

        The :class:`Motor` on the left of the robot.

    .. attribute:: right_motor

        The :class:`Motor` on the right of the robot.
    """
    def __init__(self, left=..., right=..., pwm=..., pin_factory=..., *args) -> None:
        ...
    
    @property
    def value(self):
        """
        Represents the motion of the robot as a tuple of (left_motor_speed,
        right_motor_speed) with ``(-1, -1)`` representing full speed backwards,
        ``(1, 1)`` representing full speed forwards, and ``(0, 0)``
        representing stopped.
        """
        ...
    
    @value.setter
    def value(self, value): # -> None:
        ...
    
    def forward(self, speed=..., **kwargs): # -> None:
        """
        Drive the robot forward by running both motors forward.

        :param float speed:
            Speed at which to drive the motors, as a value between 0 (stopped)
            and 1 (full speed). The default is 1.

        :param float curve_left:
            The amount to curve left while moving forwards, by driving the
            left motor at a slower speed. Maximum *curve_left* is 1, the
            default is 0 (no curve). This parameter can only be specified as a
            keyword parameter, and is mutually exclusive with *curve_right*.

        :param float curve_right:
            The amount to curve right while moving forwards, by driving the
            right motor at a slower speed. Maximum *curve_right* is 1, the
            default is 0 (no curve). This parameter can only be specified as a
            keyword parameter, and is mutually exclusive with *curve_left*.
        """
        ...
    
    def backward(self, speed=..., **kwargs): # -> None:
        """
        Drive the robot backward by running both motors backward.

        :param float speed:
            Speed at which to drive the motors, as a value between 0 (stopped)
            and 1 (full speed). The default is 1.

        :param float curve_left:
            The amount to curve left while moving backwards, by driving the
            left motor at a slower speed. Maximum *curve_left* is 1, the
            default is 0 (no curve). This parameter can only be specified as a
            keyword parameter, and is mutually exclusive with *curve_right*.

        :param float curve_right:
            The amount to curve right while moving backwards, by driving the
            right motor at a slower speed. Maximum *curve_right* is 1, the
            default is 0 (no curve). This parameter can only be specified as a
            keyword parameter, and is mutually exclusive with *curve_left*.
        """
        ...
    
    def left(self, speed=...): # -> None:
        """
        Make the robot turn left by running the right motor forward and left
        motor backward.

        :param float speed:
            Speed at which to drive the motors, as a value between 0 (stopped)
            and 1 (full speed). The default is 1.
        """
        ...
    
    def right(self, speed=...): # -> None:
        """
        Make the robot turn right by running the left motor forward and right
        motor backward.

        :param float speed:
            Speed at which to drive the motors, as a value between 0 (stopped)
            and 1 (full speed). The default is 1.
        """
        ...
    
    def reverse(self): # -> None:
        """
        Reverse the robot's current motor directions. If the robot is currently
        running full speed forward, it will run full speed backward. If the
        robot is turning left at half-speed, it will turn right at half-speed.
        If the robot is currently stopped it will remain stopped.
        """
        ...
    
    def stop(self): # -> None:
        """
        Stop the robot.
        """
        ...
    


class RyanteckRobot(Robot):
    """
    Extends :class:`Robot` for the `Ryanteck motor controller board`_.

    The Ryanteck MCB pins are fixed and therefore there's no need to specify
    them when constructing this class. The following example drives the robot
    forward::

        from gpiozero import RyanteckRobot

        robot = RyanteckRobot()
        robot.forward()

    :param bool pwm:
        If :data:`True` (the default), construct :class:`PWMOutputDevice`
        instances for the motor controller pins, allowing both direction and
        variable speed control. If :data:`False`, construct
        :class:`DigitalOutputDevice` instances, allowing only direction
        control.

    :type pin_factory: Factory or None
    :param pin_factory:
        See :doc:`api_pins` for more information (this is an advanced feature
        which most users can ignore).

    .. _Ryanteck motor controller board: https://ryanteck.uk/add-ons/6-ryanteck-rpi-motor-controller-board-0635648607160.html
    """
    def __init__(self, pwm=..., pin_factory=...) -> None:
        ...
    


class CamJamKitRobot(Robot):
    """
    Extends :class:`Robot` for the `CamJam #3 EduKit`_ motor controller board.

    The CamJam robot controller pins are fixed and therefore there's no need
    to specify them when constructing this class. The following example drives
    the robot forward::

        from gpiozero import CamJamKitRobot

        robot = CamJamKitRobot()
        robot.forward()

    :param bool pwm:
        If :data:`True` (the default), construct :class:`PWMOutputDevice`
        instances for the motor controller pins, allowing both direction and
        variable speed control. If :data:`False`, construct
        :class:`DigitalOutputDevice` instances, allowing only direction
        control.

    :type pin_factory: Factory or None
    :param pin_factory:
        See :doc:`api_pins` for more information (this is an advanced feature
        which most users can ignore).

    .. _CamJam #3 EduKit: http://camjam.me/?page_id=1035
    """
    def __init__(self, pwm=..., pin_factory=...) -> None:
        ...
    


class PhaseEnableRobot(SourceMixin, CompositeDevice):
    """
    Extends :class:`CompositeDevice` to represent a dual-motor robot based
    around a Phase/Enable motor board.

    This class is constructed with two tuples representing the phase
    (direction) and enable (speed) pins of the left and right controllers
    respectively. For example, if the left motor's controller is connected to
    GPIOs 12 and 5, while the right motor's controller is connected to GPIOs 13
    and 6 so the following example will drive the robot forward::

        from gpiozero import PhaseEnableRobot

        robot = PhaseEnableRobot(left=(5, 12), right=(6, 13))
        robot.forward()

    :param tuple left:
        A tuple of two GPIO pins representing the phase and enable inputs
        of the left motor's controller.

    :param tuple right:
        A tuple of two GPIO pins representing the phase and enable inputs
        of the right motor's controller.

    :param bool pwm:
        If :data:`True` (the default), construct :class:`PWMOutputDevice`
        instances for the motor controller's enable pins, allowing both
        direction and variable speed control. If :data:`False`, construct
        :class:`DigitalOutputDevice` instances, allowing only direction
        control.

    :type pin_factory: Factory or None
    :param pin_factory:
        See :doc:`api_pins` for more information (this is an advanced feature
        which most users can ignore).

    .. attribute:: left_motor

        The :class:`PhaseEnableMotor` on the left of the robot.

    .. attribute:: right_motor

        The :class:`PhaseEnableMotor` on the right of the robot.
    """
    def __init__(self, left=..., right=..., pwm=..., pin_factory=..., *args) -> None:
        ...
    
    @property
    def value(self):
        """
        Returns a tuple of two floating point values (-1 to 1) representing the
        speeds of the robot's two motors (left and right). This property can
        also be set to alter the speed of both motors.
        """
        ...
    
    @value.setter
    def value(self, value): # -> None:
        ...
    
    def forward(self, speed=...): # -> None:
        """
        Drive the robot forward by running both motors forward.

        :param float speed:
            Speed at which to drive the motors, as a value between 0 (stopped)
            and 1 (full speed). The default is 1.
        """
        ...
    
    def backward(self, speed=...): # -> None:
        """
        Drive the robot backward by running both motors backward.

        :param float speed:
            Speed at which to drive the motors, as a value between 0 (stopped)
            and 1 (full speed). The default is 1.
        """
        ...
    
    def left(self, speed=...): # -> None:
        """
        Make the robot turn left by running the right motor forward and left
        motor backward.

        :param float speed:
            Speed at which to drive the motors, as a value between 0 (stopped)
            and 1 (full speed). The default is 1.
        """
        ...
    
    def right(self, speed=...): # -> None:
        """
        Make the robot turn right by running the left motor forward and right
        motor backward.

        :param float speed:
            Speed at which to drive the motors, as a value between 0 (stopped)
            and 1 (full speed). The default is 1.
        """
        ...
    
    def reverse(self): # -> None:
        """
        Reverse the robot's current motor directions. If the robot is currently
        running full speed forward, it will run full speed backward. If the
        robot is turning left at half-speed, it will turn right at half-speed.
        If the robot is currently stopped it will remain stopped.
        """
        ...
    
    def stop(self): # -> None:
        """
        Stop the robot.
        """
        ...
    


class PololuDRV8835Robot(PhaseEnableRobot):
    """
    Extends :class:`PhaseEnableRobot` for the `Pololu DRV8835 Dual Motor Driver
    Kit`_.

    The Pololu DRV8835 pins are fixed and therefore there's no need to specify
    them when constructing this class. The following example drives the robot
    forward::

        from gpiozero import PololuDRV8835Robot

        robot = PololuDRV8835Robot()
        robot.forward()

    :param bool pwm:
        If :data:`True` (the default), construct :class:`PWMOutputDevice`
        instances for the motor controller's enable pins, allowing both
        direction and variable speed control. If :data:`False`, construct
        :class:`DigitalOutputDevice` instances, allowing only direction
        control.

    :type pin_factory: Factory or None
    :param pin_factory:
        See :doc:`api_pins` for more information (this is an advanced feature
        which most users can ignore).

    .. _Pololu DRV8835 Dual Motor Driver Kit: https://www.pololu.com/product/2753
    """
    def __init__(self, pwm=..., pin_factory=...) -> None:
        ...
    


class _EnergenieMaster(SharedMixin, CompositeOutputDevice):
    def __init__(self, pin_factory=...) -> None:
        ...
    
    def close(self): # -> None:
        ...
    
    def transmit(self, socket, enable): # -> None:
        ...
    


class Energenie(SourceMixin, Device):
    """
    Extends :class:`Device` to represent an `Energenie socket`_ controller.

    This class is constructed with a socket number and an optional initial
    state (defaults to :data:`False`, meaning off). Instances of this class can
    be used to switch peripherals on and off. For example::

        from gpiozero import Energenie

        lamp = Energenie(1)
        lamp.on()

    :param int socket:
        Which socket this instance should control. This is an integer number
        between 1 and 4.

    :param bool initial_value:
        The initial state of the socket. As Energenie sockets provide no
        means of reading their state, you must provide an initial state for
        the socket, which will be set upon construction. This defaults to
        :data:`False` which will switch the socket off.

    :type pin_factory: Factory or None
    :param pin_factory:
        See :doc:`api_pins` for more information (this is an advanced feature
        which most users can ignore).

    .. _Energenie socket: https://energenie4u.co.uk/index.php/catalogue/product/ENER002-2PI
    """
    def __init__(self, socket=..., initial_value=..., pin_factory=...) -> None:
        ...
    
    def close(self): # -> None:
        ...
    
    @property
    def closed(self): # -> bool:
        ...
    
    def __repr__(self): # -> Literal['<gpiozero.Energenie object closed>']:
        ...
    
    @property
    def socket(self):
        """
        Returns the socket number.
        """
        ...
    
    @property
    def value(self): # -> bool | None:
        """
        Returns :data:`True` if the socket is on and :data:`False` if the
        socket is off.  Setting this property changes the state of the socket.
        """
        ...
    
    @value.setter
    def value(self, value): # -> None:
        ...
    
    def on(self): # -> None:
        """
        Turns the socket on.
        """
        ...
    
    def off(self): # -> None:
        """
        Turns the socket off.
        """
        ...
    


class PumpkinPi(LEDBoard):
    """
    Extends :class:`LEDBoard` for the `ModMyPi PumpkinPi`_ board.

    There are twelve LEDs connected up to individual pins, so for the PumpkinPi
    the pins are fixed. For example::

        from gpiozero import PumpkinPi

        pumpkin = PumpkinPi(pwm=True)
        pumpkin.sides.pulse()
        pumpkin.off()

    :param bool pwm:
        If :data:`True`, construct :class:`PWMLED` instances to represent each
        LED. If :data:`False` (the default), construct regular :class:`LED`
        instances

    :type initial_value: bool or None
    :param initial_value:
        If :data:`False` (the default), all LEDs will be off initially. If
        :data:`None`, each device will be left in whatever state the pin is
        found in when configured for output (warning: this can be on). If
        :data:`True`, the device will be switched on initially.

    :type pin_factory: Factory or None
    :param pin_factory:
        See :doc:`api_pins` for more information (this is an advanced feature
        which most users can ignore).

    .. _ModMyPi PumpkinPi: https://www.modmypi.com/halloween-pumpkin-programmable-kit

    .. attribute:: sides

        A :class:`LEDBoard` representing the LEDs around the edge of the
        pumpkin. It contains:

        .. attribute:: left, right

            Two :class:`LEDBoard` instances representing the LEDs on the left
            and right sides of the pumpkin. They each contain:

            .. attribute:: top, midtop, middle, midbottom, bottom

                Each :class:`LED` or :class:`PWMLED` around the specified side
                of the pumpkin.

    .. attribute:: eyes

        A :class:`LEDBoard` representing the eyes of the pumpkin. It contains:

        .. attribute:: left, right

            The :class:`LED` or :class:`PWMLED` for each of the pumpkin's eyes.
    """
    def __init__(self, pwm=..., initial_value=..., pin_factory=...) -> None:
        ...
    


class JamHat(CompositeOutputDevice):
    """
    Extends :class:`CompositeOutputDevice` for the `ModMyPi JamHat`_ board.

    There are 6 LEDs, two buttons and a tonal buzzer. The pins are fixed.
    Usage::

        from gpiozero import JamHat

        hat = JamHat()

        hat.button_1.wait_for_press()
        hat.lights_1.on()
        hat.buzzer.play('C4')
        hat.button_2.wait_for_press()
        hat.off()

    :param bool pwm:
        If :data:`True`, construct :class: PWMLED instances to represent each
        LED on the board. If :data:`False` (the default), construct regular
        :class:`LED` instances.

    :type pin_factory: Factory or None
    :param pin_factory:
        See :doc:`api_pins` for more information (this is an advanced feature
        which most users can ignore).

    .. _ModMyPi JamHat: https://www.modmypi.com/jam-hat

    .. attribute:: lights_1, lights_2

        Two :class:`LEDBoard` instances representing the top (lights_1) and
        bottom (lights_2) rows of LEDs on the JamHat.

        .. attribute:: red, yellow, green

            :class:`LED` or :class:`PWMLED` instances representing the red,
            yellow, and green LEDs along the top row.

    .. attribute:: button_1, button_2

        The left (button_1) and right (button_2) :class:`Button` objects on the
        JamHat.

    .. attribute:: buzzer

        The :class:`Buzzer` at the bottom right of the JamHat.
    """
    def __init__(self, pwm=..., pin_factory=...) -> None:
        ...
    
    def on(self): # -> None:
        """
        Turns all the LEDs on and makes the buzzer play its mid tone.
        """
        ...
    
    def off(self): # -> None:
        """
        Turns all the LEDs off and stops the buzzer.
        """
        ...
    


